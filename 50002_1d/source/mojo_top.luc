global Alufn{
  const ADD   = 6b000000;
  const SUB   = 6b000001;
  const MUL   = 6b000010;
  const AND   = 6b011000;
  const OR    = 6b011110;
  const XOR   = 6b010110;
  const A     = 6b011010;
  const SHL   = 6b100000;
  const SHR   = 6b100001;
  const SRA   = 6b100011;
  const CMPEQ = 6b110011;
  const CMPLT = 6b110101;
  const CMPLE = 6b110111;
}

module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield 
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield, order 0-4: up, mid, down, left, right.
    input io_dip [3][8]    // DIP switches on IO Shield
    //output display_select[3][3], // 3x3 display selector to common anode. ACTIVE HIGH. output 1 for on.
    //output display_digit[7], // 7seg display digits to segment cathode. ACTIVE LOW. output 0 for on.
    //input arrow_btn[4],      // Arrow buttons. TODO: Will need to encode or prioritise or debounce etc.
    //input start_game,        // Start/restart game button. Connected to reset.
    //output win_led,
    //output lose_led
  ) {
  
  sig rst;                  // reset signal
  sig zero;                 // fixed 1bit 0.
  sig arrow_press[4];          // arrow_btn after coditioning and edge detection.
  sig easy_numlist[10][8]; // array of 10 8-bits number for easy difficulty
  sig normal_numlist[10][8]; // array of 10 8-bits number for normal difficulty
  sig hard_numlist[10][8]; // array of 10 8-bits number for hard difficulty
  var i;
  var j;
  var empty_slots;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    // For arrow_btn, ed detects rising edges, bc conditions input.
    edge_detector ed0(#RISE(1), #FALL(0));
    button_conditioner bc0;
    edge_detector ed1(#RISE(1), #FALL(0));
    button_conditioner bc1;
    edge_detector ed2(#RISE(1), #FALL(0));
    button_conditioner bc2;
    edge_detector ed3(#RISE(1), #FALL(0));
    button_conditioner bc3;
    
    counter randseed(.rst(zero), #SIZE(32)); // unresettable counter.
    
    .rst(rst) {
      //dff game_state[3][3][4](#INIT(36hfffffffff)); // row/col are backwards: 36h123456789
                                                      // is (9,8,7)(6,5,4)(3,2,1)
      dff game_state[3][3][4](#INIT(36h98f9ff885)); // FOR TESTING.
                                                    // row/col are backwards: (1,2,3)(4,5,6)(7, ,8)
      dff rowindex[2]; // Common registers for indexing row/col.
      dff colindex[2];
      
      
      dff new_tile_index1[4];
      dff new_tile_index2[4];
      fsm game_step = { // Current step in game logic.
        WAIT_START,
        COUNT_EMPTY,
        MAKE_RAND1,
        MAKE_RAND2,
        SELECT_NUM,
        SELECT_POS,
        ADD_NUM,
        WAIT_INPUT,
        SHIFT,
        CHECK10,
        WIN,
        LOSE
      };
      
      fsm randint_step = { // Current substep in randint generation
        BITMASK,
        MULTIPLY,
        EXTRACT
      };
      
      dff shift_direction[2];
      dff shift_line[2];
      dff shift_i[2];
      dff shift_row[3][4]; // working row for row collation
      dff shift_row_pointer[2]; // Destination pointer for row collation
      fsm shift_step = { // substep in row/col shifting.
        COLLATE_OUT1, // collate out to working row
        COLLATE_OUT2,
        COLLATE_OUT3,
        COLLATE_OUT4,
        COMPARE,
        COLLATE_IN1, // collate back in to game state.
        COLLATE_IN2,
        COLLATE_IN3,
        INCREMENT
      };
      
      multiplex_display m_display;
      pn_gen rand_gen;
    }
  }
  
  alu alu;
  encoder direction_enc(#WIDTH(4));
  
  
  
  always {
    rand_gen.next = 1;
    
    // START: Fixed signals
    reset_cond.in = ~rst_n; // || start_game;   // input raw inverted reset signal. start_game also resets.
    rst = reset_cond.out;     // conditioned reset
    
    spi_miso = bz;            // not using SPI
    spi_channel = bzzzz;      // not using flags
    avr_rx = bz;              // not using serial port
    
    zero = 1b0;
    
    io_led = {8b0,8b0,8b0};       // Display only alu output

    rand_gen.seed = randseed.value; // Seed based on absolute time. 
    easy_numlist = {8b000001, 8b000001,8b000001,8b000001,8b000010,8b000010,8b000010,8b000001,8b000011,8b000011};
    normal_numlist = {8b000001, 8b000001,8b000001,8b000010,8b000010,8b000010,8b000010,8b000100,8b000011,8b000011};
    hard_numlist = {8b000001, 8b000001,8b000001,8b000010,8b000010,8b000010,8b000010,8b000100,8b000011,8b000011};

    // END: Fixed signals
    
    
    
    // START: defaults
    game_state.d = game_state.q; // Needed to maintain state
    rowindex.d = rowindex.q;
    colindex.d = colindex.q;
    
    alu.alufn = 6b000000;
    alu.a = 8b0;
    alu.b = 8b0;
    led = 8b0;
    //win_led = 1b0;
    //lose_led = 1b0;
    
    bc0.in = io_button[0];
    ed0.in = bc0.out;
    bc1.in = io_button[2];
    ed1.in = bc1.out;
    bc2.in = io_button[3];
    ed2.in = bc2.out;
    bc3.in = io_button[4];
    ed3.in = bc3.out;
    arrow_press = c{ed3.out, ed2.out, ed1.out, ed0.out};
    direction_enc.in = arrow_press;
    //END: defaults
    
    
    
    // START: Display block
    m_display.game_state = game_state.q;
    //display_select = m_display.display_select;
    //display_digit = m_display.display_digit;
    io_sel = ~ c{1b0, m_display.display_select[0][0], m_display.display_select[0][1],  m_display.display_select[0][2]};
    io_seg = c{1b1, m_display.display_digit};
    
    io_led[0] = c{game_state.q[2][1], game_state.q[2][2]};
    io_led[1] = c{game_state.q[1][2], game_state.q[2][0]};
    io_led[2] = c{game_state.q[1][0], game_state.q[1][1]};
    // END: Display block
    
    
    
    //START: Game block
    case(game_step.q){
      game_step.WAIT_START:
        // FOR TESTING.
        if(|arrow_press){
          if (direction_enc.out == 0){
            game_state.d[0][1] =  game_state.q[0][1] + 1;
          }
          if (direction_enc.out == 1){
            game_state.d[2][1] =  game_state.q[2][1] + 1;
          }
          if (direction_enc.out == 2){
            game_state.d[1][0] =  game_state.q[1][0] + 1;
          }
          if (direction_enc.out == 3){
            game_state.d[1][2] =  game_state.q[1][2] + 1;
          }
        }
        game_step.d = game_step.WAIT_INPUT;
        
      game_step.COUNT_EMPTY:
        for (i = 0; i < 3; i++) {
          for(j=0; j < 3; j++) {
          }
        }
        if (empty_slots == 15) { // go to next step
        }
        
      game_step.MAKE_RAND1:
        case(randint_step.q) {
          randint_step.BITMASK: // shift right by 4
            alu.a = rand_gen.num[20:13];
            alu.b = 8b00000100;
            alu.alufn = 6b100001;
          randint_step.MULTIPLY: // multiply by 10
            alu.alufn = 6b000010;
            alu.a = alu.out; // I need to convert this to binary point but idk how
            alu.b = 8b00001010;
          randint_step.EXTRACT:
            new_tile_index1.d = alu.out[7:4]; // store 4 highest bits into new_tile_num
        }
        
      game_step.MAKE_RAND2:
        case(randint_step.q) {
          randint_step.BITMASK: // shift right by 4
            alu.a = rand_gen.num[20:13];
            alu.b = 8b00000100;
            alu.alufn = 6b100001;
          randint_step.MULTIPLY: // multiply by 10
            alu.alufn = 6b000010;
            alu.a = alu.out; // I need to convert this to binary point but idk how
            alu.b = 8b00001010;
          randint_step.EXTRACT:
            new_tile_index2.d = alu.out[7:4]; // store 4 highest bits into new_tile_num
        }
        
      game_step.SELECT_NUM:
        new_tile_index1.d = new_tile_index1.q; // preserve for subsequent cycle
        new_tile_index2.d = new_tile_index2.q;
        game_state.d = game_state.q; // null op
        
      game_step.SELECT_POS:
        game_state.d = game_state.q; // null op
        
      game_step.ADD_NUM:
        game_state.d = game_state.q; // null op
        
      game_step.WAIT_INPUT:
        if(|arrow_press){
          shift_direction.d = direction_enc.out;
          game_step.d = game_step.SHIFT;
          // TODO: Any other setup.
          shift_step.d = shift_step.COLLATE_OUT1;
          shift_line.d = 0;
        }
      
      // START: Shift board state. complicated state deserves it's own start and end.
      game_step.SHIFT:
        shift_direction.d = shift_direction.q;
        shift_line.d = shift_line.q;
        shift_i.d = shift_i.q;
        shift_row.d = shift_row.q;
        shift_row_pointer.d = shift_row_pointer.q;
        
        case(shift_step.q){
          
          shift_step.COLLATE_OUT1: // Setup collating variables. BEFORE loop
            shift_row.d = {4hf,4hf,4hf};
            shift_row_pointer.d = 0;
            shift_i.d = 0;
            shift_step.d = shift_step.COLLATE_OUT2;
            
          shift_step.COLLATE_OUT2: // Setup row/col indexes for loop. INSIDE loop
            case (shift_direction.q){
              0: // Up
                rowindex.d = shift_i.q;
                colindex.d = shift_line.q;
              1: // Down
                rowindex.d = 2 - shift_i.q;
                colindex.d = shift_line.q;
              2: // Left
                rowindex.d = shift_line.q;
                colindex.d = shift_i.q;
              3: // Right
                rowindex.d = shift_line.q;
                colindex.d = 2 - shift_i.q;
            }
            shift_step.d = shift_step.COLLATE_OUT3;
            
          shift_step.COLLATE_OUT3: // Do collation. INSIDE loop
            alu.a = c{ 4h0, game_state.q[rowindex.q][colindex.q] };
            alu.b = 8h0f;
            alu.alufn = Alufn.CMPEQ;
            if (alu.out==0){ // if num != 0xf
              shift_row.d[shift_row_pointer.q] = game_state.q[rowindex.q][colindex.q];
              game_state.d[rowindex.q][colindex.q] = 4hf; // also clear cell for COLLATE_IN later.              
              shift_row_pointer.d = shift_row_pointer.q + 1;
            }
            shift_step.d = shift_step.COLLATE_OUT4;
            
          shift_step.COLLATE_OUT4: // Loop check for collate out.
            shift_i.d = shift_i.q + 1;
            shift_step.d = shift_step.COLLATE_OUT2;
            if (shift_i.q==2){
              shift_step.d = shift_step.COMPARE;
            }
          
          
          shift_step.COMPARE:
            // If row is empty, skip
            // Otherwise, compare adjacent cells. If they're the same, combine.
            // In general case, should be a loop, but for 3x3, 2 if statements is enough.
            if (shift_row.q[0] == shift_row.q[1] && shift_row.q[0] != 4hf) {
              alu.a = c{ 4h0, shift_row.q[0] };
              alu.b = 8h01;
              alu.alufn = Alufn.ADD;
              shift_row.d[0] = alu.out[3:0];
              shift_row.d[1] = 4hf;
            } else if (shift_row.q[1] == shift_row.q[2] && shift_row.q[1] != 4hf) {
              alu.a = c{ 4h0, shift_row.q[1] };
              alu.b = 8h01;
              alu.alufn = Alufn.ADD;
              shift_row.d[1] = alu.out[3:0];
              shift_row.d[2] = 4hf;
            }
            shift_step.d = shift_step.COLLATE_IN1;
          
          
          shift_step.COLLATE_IN1: // Setup collating variables. BEFORE loop
            shift_row_pointer.d = 0;
            shift_i.d = 0;
            shift_step.d = shift_step.COLLATE_IN2;
          
          shift_step.COLLATE_IN2: // Do collation. INSIDE loop
            alu.a = c{ 4h0, shift_row.q[shift_i.q] };
            alu.b = 8h0f;
            alu.alufn = Alufn.CMPEQ;
            if (alu.out==0){ // if num != 0xf
              case (shift_direction.q){
                0: // Up
                  game_state.d[shift_row_pointer.q][shift_line.q] = shift_row.q[shift_i.q];
                1: // Down
                  game_state.d[2-shift_row_pointer.q][shift_line.q] = shift_row.q[shift_i.q];
                2: // Left
                  game_state.d[shift_line.q][shift_row_pointer.q] = shift_row.q[shift_i.q];
                3: // Right
                  game_state.d[shift_line.q][2-shift_row_pointer.q] = shift_row.q[shift_i.q];
              }
              shift_row_pointer.d = shift_row_pointer.q + 1;
            }
            shift_step.d = shift_step.COLLATE_IN3;
          
          shift_step.COLLATE_IN3: // Loop check for collate in.
            shift_i.d = shift_i.q + 1;
            shift_step.d = shift_step.COLLATE_IN2;
            if (shift_i.q==2){
              shift_step.d = shift_step.INCREMENT;
            }
          
          
          shift_step.INCREMENT:
            shift_line.d = shift_line.q + 1;
            if(shift_line.q == 2){
              game_step.d = game_step.CHECK10;
              rowindex.d = 2d0;
              colindex.d = 2d0;
            } else {
              shift_step.d = shift_step.COLLATE_OUT1;
            }
        
        }
      // END: Shift board state
      
      game_step.CHECK10:
        rowindex.d = rowindex.q + 1;
        if (rowindex.q == 2){ // if row/col is at 2, instead of incrementing, reset to 0.
          rowindex.d = 0;
          
          colindex.d = colindex.q + 1;
          if (colindex.q == 2){ // End of check. Next round.
            colindex.d = 0;
            game_step.d = game_step.COUNT_EMPTY;
          }
        }
        
        alu.a = 8d10;
        alu.b = c{ 4h0, game_state.q[rowindex.q][colindex.q] };
        alu.alufn = Alufn.CMPLE;
        if (alu.out){ // Needs to be at bottom to overwrite COUNT_EMPTY if at [2][2]
          if (game_state.q[rowindex.q][colindex.q] != 4hf){
            game_step.d = game_step.WIN;
          }
        }
        
      game_step.WIN:
        //win_led = 1b1;
        led[3:0] = 4hf;
        
      game_step.LOSE:
        //lose_led = 1b1;
        led[7:4] = 1b1;
    }
    // END: Game block
  }
}